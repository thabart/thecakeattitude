<html>
	<head>		
		<meta charset="utf-8">
		<title>Cake attitude</title>
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2" />
		<!-- Jquery -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.js"></script>
		<!-- Bootstrap -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha.6/js/bootstrap.js"></script>
		<!-- Phaser lib -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/2.6.2/phaser.js"></script>
		<!-- Socket IO -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.7.3/socket.io.js"></script>
		<!-- CSS Libraries -->
		<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha.6/css/bootstrap.css">
		<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css" >
		<style type="text/css">	
		</style>
	</head>
	<body>
		<div style="width:980px; margin: 0 auto;">
			<div id="game">
			
			</div>
			<div style="background-color: gray;">
				<div class="col-md-12">
					<input type="text" class="form-control" style="width: 300px; display:inline-block;" id="message-text" />
					<button class="fa fa-envelope-o" style="display: inline-block;" id="send-message"></button>
				</div>
			</div>
		</div>
	</body>
	<script type="text/javascript">
		$(document).ready(function() {	
			var Player = function(id, sprite) {
				this.id = id;
				this.sprite = sprite;
				this.direction = [];
				
				function updateDirection(dir, val) {
					var result = false;
					if (dir.isDown && this.direction.indexOf(val) == -1) {
						this.direction.push(val);
						result = true;
					} else if (dir.isUp && this.direction.indexOf(val) != -1) {
						this.direction.splice(this.direction.indexOf(val), 1);		
						result = true;
					}
					
					return result;
				}
				
				this.remove = function() {
					this.sprite.destroy();
				};
				
				// Update direction.
				// Returns : true if the direction changes.
				this.updateDirection = function(cursors) {
					var result = false;
					result = result || updateDirection.call(this, cursors.up, 0);
					result = result || updateDirection.call(this, cursors.right, 1);
					result = result || updateDirection.call(this, cursors.down, 2);
					result = result || updateDirection.call(this, cursors.left, 3);
					return result;
				};
				
				// Update the properties.
				this.update = function(x, y, direction) {
					this.sprite.x = x;
					this.sprite.y = y;
					this.direction = direction;
				};
				
				// Update player position.
				this.updatePosition = function() {					
					this.sprite.body.velocity.x = 0;
					this.sprite.body.velocity.y = 0;
					if (this.direction.indexOf(0) != -1) {						
						this.sprite.body.velocity.y = -200;
					} else if (this.direction.indexOf(2) != -1) {			
						this.sprite.body.velocity.y = 200;						
					}
					
					if (this.direction.indexOf(1) != -1) {	
						this.sprite.body.velocity.x = 200;
					} else if (this.direction.indexOf(3) != -1) {			
						this.sprite.body.velocity.x = -200;						
					}
				};
				
				// Reset the direction.
				this.resetDirection = function() {
					this.direction = [];
				};
			}
		
			var canvas = function(opts) {			
				this.fields = {
					game: null,
					map: null,
					cursors: null,
					player: null,
					players: [],
					message: null,
					layers : {
						alimentation : null,
						earth : null,
						ground: null,
						collision : null
					}
				};
					
				function preload() {
					this.fields.game.load.tilemap('game', 'http://localhost:3000/public/map/map.json', null, Phaser.Tilemap.TILED_JSON);
					this.fields.game.load.image('tallgrass', 'http://localhost:3000/public/map/tilesets/tallgrass.png');
					this.fields.game.load.image('farming_fishing', 'http://localhost:3000/public/map/tilesets/farming_fishing.png');
					this.fields.game.load.image('tiles', 'http://localhost:3000/public/map/tilesets/tiles.png');
					this.fields.game.load.image('player', 'http://localhost:3000/public/map/character/phaser-dude.png');
				}
				
				function create() {	
					// Start the Arcade physics systems.
					this.fields.game.physics.startSystem(Phaser.Physics.ARCADE);
					// Change background color.				
					this.fields.game.stage.backgroundColor = '#787878';
					// Keep running on losing focus
					this.fields.game.stage.disableVisibilityChange = true;
					// Add tile map and tile set image.
					this.fields.map = this.fields.game.add.tilemap('game');
					this.fields.map.addTilesetImage('tallgrass', 'tallgrass');
					this.fields.map.addTilesetImage('farming_fishing', 'farming_fishing');
					this.fields.map.addTilesetImage('tiles', 'tiles');
					// Add input field
					// Add the layers.
					this.fields.layers.collision = this.fields.map.createLayer('Collision');
					this.fields.layers.ground = this.fields.map.createLayer('Ground');
					this.fields.layers.earth = this.fields.map.createLayer('Earth');
					this.fields.layers.alimentation = this.fields.map.createLayer('Alimentations');
					// Specify which tile can collide.
					this.fields.map.setCollision(421, true, 'Collision');		
					// Add the player to the world.
					this.fields.player = new Player(null, this.fields.game.add.sprite(0, 0, 'player'));
					this.fields.game.physics.arcade.enable(this.fields.player.sprite);
					// Change the world size the match the size of this layer.
					this.fields.layers.earth.resizeWorld();				
					// Make the camera follow the sprite.
					this.fields.game.camera.follow(this.fields.player.sprite, Phaser.Camera.FOLLOW_LOCKON, 0.1, 0.1);	
					this.fields.cursors = this.fields.game.input.keyboard.createCursorKeys();				
					if (opts && opts.createCallback) {
						opts.createCallback();
					}
				}
							
				function update() {
					var self = this;
					this.fields.players.forEach(function(p) {
						if (!self.fields.game.physics.arcade.collide(p.sprite, self.fields.layers.collision)) {
							p.updatePosition();							
						}
					});
					
					if (this.fields.game.physics.arcade.collide(this.fields.player.sprite, this.fields.layers.collision)) {
						return;
					}
					
					isPositionUpdated = this.fields.player.updateDirection(this.fields.cursors);
					this.fields.player.updatePosition();						
					if (isPositionUpdated && opts && opts.updateCallback) {
						opts.updateCallback(this.fields.player);
					}
					
					/*				
					if (this.fields.message != null) {
						this.fields.message.x = Math.floor(this.fields.player.x);
						this.fields.message.y = Math.floor(this.fields.player.y);
					}
					*/
				}
				
				function fadeMessage() {
					this.fields.message.destroy();
					this.fields.message = null;
				}
				
				function getPlayer(id) {
					var i;
					for (i = 0; i < this.fields.players.length; i++) {
						if (this.fields.players[i].id === id) {
							return this.fields.players[i];
						}
					}
				
					return false
				}
				
				this.init = function() {
					var self = this;
					this.fields.game = new Phaser.Game(980, 600, Phaser.AUTO, 'game', { preload : function() { preload.call(self); }, create : function() { create.call(self); }, update : function() { update.call(self); } });
				};
				this.displayMessage = function(txt) {
					if (this.fields.message != null) {
						this.fields.message.destroy();
						this.fields.message = null;
					}
					
					var style = { font: "Arial", fill: "black", wordWrap: true, wordWrapWidth: this.fields.player.sprite.width, align: "center" };
					this.fields.message = this.fields.game.add.text(Math.floor(this.fields.player.sprite.x), Math.floor(this.fields.player.sprite.y), txt, style);
					this.fields.game.time.events.add(Phaser.Timer.SECOND * 5, fadeMessage, this);
				};
				this.cleanPlayers = function() {
					this.fields.players.forEach(function(player) {
						player.remove();
					});
					
					this.fields.players = [];
				};
				// Add a new player to the map.
				this.addPlayer = function(id, x, y, direction) {
					var newPlayer = this.fields.game.add.sprite(x, y, 'player');
					this.fields.game.physics.enable(newPlayer, Phaser.Physics.ARCADE)
					var newPlayer = new Player(id, newPlayer);
					newPlayer.direction = direction;
					this.fields.players.push(newPlayer);
				};
				// Remove the player from the map.
				this.removePlayer = function(id) {
					var player = getPlayer.call(this, id);
					if (!player) {
						return;
					}
					
					player.remove();
					this.fields.players.splice(this.fields.players.indexOf(player), 1);						
				};
				// Update the player position.
				this.updatePlayer = function(id, x, y, direction) {
					var player = getPlayer.call(this, id);
					if (!player) {
						return;
					}
					
					player.update(x, y, direction);
				};
			};
			
			var socketProxy = function(opts) {
				this.socket = null;
				
				function onSocketConnected() {
					console.log('Connected to socket server');
					
				}
			
				this.init = function() {					
					this.socket = io('http://localhost:3001').connect();
					this.socket.on('connect', function() {
						console.log('socket connected');
						if (opts && opts.socketConnectedCallback) {
							opts.socketConnectedCallback();
						}
					});
					this.socket.on('disconnect', function() {
						console.log('socket disconnected');
					});
					this.socket.on('new_player', function(data) {
						console.log('new player');
						if (opts && opts.newPlayerCallback) {
							opts.newPlayerCallback(data);
						}
					});
					this.socket.on('remove_player', function(data) {
						console.log('remove player');
						if (opts && opts.removePlayerCallback) {
							opts.removePlayerCallback(data);
						}
					});
					this.socket.on('move_player', function(data) {
						if (opts && opts.movePlayerCallback) {
							opts.movePlayerCallback(data);
						}
					});
				};
				// Send a message to connect the player.
				this.newPlayer = function(x, y, direction) {
					this.socket.emit('new_player', { x : x, y : y, direction : direction });
				};
				// Send a message to update the player position.
				this.updatePlayer = function(x, y, direction) {
					this.socket.emit('move_player', {x : x, y : y, direction : direction });
				};
			};
			
			var proxy = new socketProxy({
				socketConnectedCallback : function() {
					// Clean all the players.
					c.cleanPlayers();
					// Send a message to connect the player.
					proxy.newPlayer(c.fields.player.sprite.x, c.fields.player.sprite.y, c.fields.player.direction);
				},
				newPlayerCallback: function(data) {
					c.addPlayer(data.id, data.x, data.y, data.direction);
				},
				removePlayerCallback: function(data) {
					c.removePlayer(data.id);
				},
				movePlayerCallback: function(data) {
					c.updatePlayer(data.id, data.x, data.y, data.direction);					
				}
			});
			var c = new canvas({
				createCallback: function() {
					proxy.init();
				},
				updateCallback: function(p) {
					proxy.updatePlayer(p.sprite.x, p.sprite.y, p.direction);
				}
			});
			c.init();
			
			// Send message.
			$("#send-message").click(function() {
				var txt = $("#message-text").val();
				c.displayMessage(txt);
			});			
			
		});
	</script>
</html>